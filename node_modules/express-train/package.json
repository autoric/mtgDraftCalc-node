{
  "name": "express-train",
  "description": "express 3 framework",
  "version": "0.0.19",
  "author": {
    "name": "Erin Noe-Payne",
    "email": "saizul@gmail.com"
  },
  "contributors": [
    {
      "name": "Erin Noe-Payne",
      "email": "saizul@gmail.com"
    },
    {
      "name": "Paul Vencill",
      "email": "paul.vencill@gmail.com"
    }
  ],
  "dependencies": {
    "boilerplate": "latest",
    "connect": "latest",
    "express": "latest",
    "underscore": "latest",
    "commander": "latest",
    "handlebars": "~1.0.7",
    "winston": "latest",
    "nodemon": "latest",
    "repl.history": "latest"
  },
  "devDependencies": {
    "mocha": "latest",
    "should": "latest"
  },
  "keywords": [
    "express",
    "train",
    "framework",
    "web",
    "webapp",
    "MVC"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/autoric/express-train"
  },
  "main": "./lib/app.js",
  "bin": {
    "train": "./bin/train"
  },
  "scripts": {
    "prepublish": "npm prune"
  },
  "engines": {
    "node": ">= 0.6.0"
  },
  "_id": "express-train@0.0.19",
  "_from": "express-train@latest",
  "readme": "# All Aboard!\n\nWelcome to Express Train! Express Train is a framework for building [12 factor](http://www.12factor.net/) web applications in nodejs, based on [express 3](http://expressjs.com/).\n\nTo get started:\n```\nnpm install -g express-train\n```\n\nThen create a new project by typing: \n\n```\ntrain new <projname>\n```\n\nThat command will create a directory called `projname` that in turn has a fully scaffolded train app, and pulls the dependencies\ndefined in the app template.  Express-train uses [Boilerplate](http://github.com/pvencill/boilerplate) for scaffolding the app, and lets you\nrequest a different template by passing a folder location or a git repo to the -b option.\n\n# Why use Express Train?\n\nBecause express is excellent, but it makes no decisions for you and does not enforce any structure.  The result can be a steep learning curve for new developers to node, or to a given project. Even very good developers using the same tools to build towards the same goals can end up with very different products. And individuals or organizations can struggle to define a repeatable process or consistent structure for their projects.\n\nOur goal is to provide a framework that will make some reasonable decisions to get a new project up and running quickly and give a consistent structure for your web applications, without asking you to sacrifice any of the flexibility you are used to from express.  We also aim to provide a powerful and fully featured set of CLI tools to set up project scaffolding, explore your application, and define custom boilerplates for any situation.\n\n# How it works\n\n\n## The file structure\n\nAn express train project starts with a specific file structure:\n\n```\napp\n  /controllers      -- application controllers (automatically loaded onto app.controllers)\n  /lib              -- application specific modules you will use to glue your app together\n  /middleware       -- application middleware (automatically loaded onto app.middleware)\n  /models           -- application models (automatically loaded onto app.models)\n  /public           -- static content (html, js, css, etc)\n  /views            -- view templates (loaded into express' view engine)\n  index.js          -- basic index file that will run your application\n\nbin                 -- executable scripts\ndoc                 -- documentation\nconfig              -- environmental configuration files\ntest                -- tests\n\npackage.json        -- npm package.json (needs to have express-train as a dependency)\n```\n\nFor a fully functioning example, you can view [express-train-template](https://github.com/autoric/express-train-template). This is the default  project scaffolding that ships with Express Train.\n\n## Modules (controllers, models, middleware, and libs)\n\nAll express-train modules will have the following signature\n\n```javascript\nmodule.exports = function(app) {\n  var model = {/*...*/}\n  return model;\n}\n```\n\nAn example model using [mongoose](https://github.com/LearnBoost/mongoose):\n```javascript\n// models/Users.js\n\nvar mongoose = require('mongoose');\n\nmodule.exports = function (app) {\n    var UserSchema = new mongoose.Schema({\n        username:{ type:String, required:true, unique:true },\n        email:{ type:String, required:false, unique:false },\n        password:{ type:String, required:true}\n    });\n\n    return mongoose.model('users', UserSchema);\n}\n```\n\nFollowing the same example, a controller might look like:\n```javascript\n// controllers/Home.js\n\nmodule.exports = function (app) {\n    var Users = app.models.Users;\n\n    var controller = {};\n\n    controller.index = function (req, res, next) {\n            var username = req.params.username;\n            Users.findOne({username:username}, {password:0}).exec(function (err, user) {\n                if (err) return next(err);\n                if (user === null) return res.send(404);\n                res.locals.user = user;\n                res.render('index');;\n            })\n        }\n\n    controller.signup = function (req, res, next) {\n            res.render('signup');\n        }\n\n\n    return controller;\n}\n```\n\n## Autoloading and Application Lifecycle\n\nThe app argument received by each of your modules is an express 3 application - find the documentation at the [express api](http://expressjs.com/api.html). On top of the standard express application, Express Train autoloads files from the project to extend the app. At several stages, lifecycle events are fired, which are used to determine when your autoloaded lib files are invoked.\n\n- app/lib (libs are registered to be autoloaded at a lifecycle event, according to an index.js file you define)\n- config/[NODE_ENV].json -> app.config\n  - lifecycle event: 'init' (you may want to initiate logging or db connections here)\n- app/models -> app.models\n- app/middleware -> app.middleware\n- app/controllers -> app.controllers\n  - lifecycle event: 'setup' (set up middleware stack, route handlers, etc)\n- application start -> app.server (node http server instance)\n  - lifecycle event: 'start' (set up socket.io or other functionality requiring app.server)\n\n\n\n### Configuration\n\nEnvironmental configuration is stored by default in the config directory. These should be values specific to an environment, such as database connection strings, port number, etc. When the application starts, it inspects NODE_ENV environmental variable and looks for a .json file in the config directory with a corresponding name (e.g. config/production.json).  If one is not found, it will look for config/default.json.   Because some web hosts expect apps to extract configuration parameters such as port number from environmental variables they set, express-train config file values will be compiled as handlebars templates with the environmental variables provided as data for the template.  As an example, if the environment is exposing a variable named MONGO_URL that represents the connection string for your MongoDB instance, your config file might have the following entry:\n\n```javascript\n{\n  \"mongoUrl\": \"{{MONGO_URL}}\"\n}\n```\n\nWhen config is complete, the values are all loaded on the app.config object, and so app.config.mongoUrl would evaluate to the value provided by the environment variable.\n\n### Models, middleware, controllers\n\nBy default, modules are loaded to these hashes based on their file name (models/Users.js is loaded on to app.models.Users;  controllers/home.js to app.controllers.home and so on). However if the directory contains an index.js file, that file will be loaded instead and override the default behavior, allowing you to take explicit control of the autoloading process. The index.js should be written as Express Train module. It will be invoked, and the return value will be loaded onto the corresponding hash.\n\n```javascript\n// models/index.js\n\nmodule.exports = function(app) {\n  return {\n    people: require('./Users')(app),\n    blogs: require('./Blogs')(app)\n  }\n}\n//app.models.people, app.models.blogs are now available\n```\n\n### Lib\n\nThe app/lib directory will contain modules your application will use internally. Some of these, such as your routing and application middleware stack, you will want to autoload during application startup. Others you may not.\n\nTo configure autoloading, Express Train uses an index.js or index.json file. This file will tell express train which lib modules to autoload at which lifecycle stages of the application startup. The return value should be a json object in which each key is a valid lifecycle stage, and each value is either a string or array of strings for the file to be autoloaded. The order declared will be the order loaded.\n\n```javascript\nmodule.exports = {\n    onInit: 'logging',\n    onSetup: ['views', 'routes', 'middleware'],\n    onStart: 'socketio'\n}\n/*\n    'init' event: app.config is now available. lib/logging.js will be loaded\n    'setup' event: app.models, app.middleware, app.controllers are now available. lib/views.js, lib/routes.js, lib/middleware.js will be loaded in that order\n    'start' event: app.server, a node htttp server is now available. lib/socketio.js will be loaded\n*/\n```\n\n\n# API\n\nExpress Train is meant to be installed and used globally. It provides a rich cli for creating boilerplates, building scaffolding for new projects, and running and development.\n\n## CLI\n\nTo use the Express Train CLI, install the module globally with\n```\nnpm install -g express-train\n```\n\nThe cli is now available via\n```sh\n$ train <command>\n```\n\nAll commands support --help for inline help on usage and options.\n\n### train new <destination> [options]\n\nCreates a new train project at the destination folder. Supports the following options:\n\n- `-b, --boilerplate` Specify the project boilerplate to use. If left blank, will use your 'default' boilerplate - on install this will be the standard express train template. However you can specify any valid git url (will be cloned to make your new project), local directory (will be copied to make your new project) to be used as a template, or registered alias. See documentation on train boilerplate for more info.\n- `-v, --verbose' Verbose output\n\n### train run\n\nThis is a convenience method to start your application. Run from the root directory of an express trian project it will attempt to resolve a main file via package.json's main property or an index.js file in your application root directory, so in most cases it will be equivalent to `node .`. Otherwise it will require app/index.js and invoke the start() method.\n\n### train cycle\n\nLike train run, this is a convenience method for development. The app file will be resolved in the same way as run, but will be invoked using nodemon to stop / start the application on file changes.\n\n### train console\n\nStarts a standard node console in the context of your express train application. Adds the app object to the global scope for easy testing / experimenting / development.  Also supports repl history for ease of use.\n\n### train boilerplate <command>\n\nExpress train supports the concept of boilerplates. These are project templates that can be specified when you generate a new express train project. For example, you may have one template that you like to use for mobile applications, and another for realtime apps with socket.io.  A boilerplate is just a valid express train directory structure with any customizations or standard configuration you want to put in place. A boilerplate can be defined as a local directory structure that will be copied, or a git url which will be cloned.\n\n### train boilerplate register <alias> <source>\n\nRegisters any valid directory or git url as a source with he given alias. On install express train provides two boilerplates - basic and train. It also registers 'train' as the default boilerplate that will be used in the absence of a -b option on train new.\n\n```\ntrain boilerplate register mobileTemplate ~/local/mobileTemplate\ntrain boilerplate register singlePageApp https://github.com/autoric/example-template.git\ntrain boilerplate register default singlePageApp\n\ntrain new -b mobileTemplate\n# creates a new project using mobileTemplate as the boilerplate\n\ntrain new -b singlePageApp\n# creates a new project using singlePageApp as the boilerplate\n\ntrain new\n# creates a new project using singlePageApp as the boilerplate\n```\n\n### train boilerplate view <alias>\n\nReturns the source for an alias.\n\n```\ntrain boilerplate view singlePageApp\n# returns https://github.com/autoric/example-template.git\n```\n\n### train boilerplate unregister <alias>\n\nDeletes the alias for your boilerplate.\n\n## Programmatic API\n\n**train(directory, [locations])**\n\n*directory* - The root directory of a correctly formatted express-train file structure.\n\n*locations* - Object representing the location of directories and configuration files relative to the application directory. Allows you to override Express Train defaults for autoloading locations. Possible locations and their default values:\n\n```\n{\n    pkg: '../package.json',\n    config:'../config',\n    logs: '../logs',\n    models:'models',\n    views:'views',\n    lib:'lib',\n    controllers:'controllers',\n    pub:'public',\n    middleware:'middleware',\n    locals:'locals'\n}\n```\n\nCreates an express train application, autoloading configuration, models, etc. Returns the Express Train application, which has not been started yet.\n\n```javascript\nvar train = require('express-train');\n\n//setup an application with a custom config file location\nvar app = train(__dirname, { config: '/etc/labs/config.json'});\napp.start();\n```\n\n# Credits\n\nExpress Train was heavily influenced by the work of Skookum and [Base12](https://github.com/Skookum/base12).  Many thanks for sharing their work and ideas with the community!\n\n#License\n\n(The MIT License)\n\nCopyright (c) 2012 Erin Noe-Payne\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "ReadMe.md"
}
